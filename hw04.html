<html> <head> <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"> <meta http-equiv="Pragma" content="no-cache"> <meta http-equiv="Expires" content="0"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="robots" content="noindex"> <title></title>
<script> MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } }; </script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link rel="stylesheet" href="csci-371.css">
</head><body><div class="content">

<a href="csci-371.html"><b><- back</b></a><!--<button onClick="window.print()" style="float:right;">print this page</button>-->

<center><b>hw04</b>
<a href="https://docs.google.com/spreadsheets/d/1WaJkilThuOXpyYGPvUCOo2pz12IhGobCWyKco-HACGY/edit?usp=sharing">help hours</a> | <a href="https://github.com/james-bern/CSCI-371">codebase</a> | <a href="https://github.com/james-bern/CSCI-371/wiki">docs</a> | <a href="notes.html">notes</a> | <a href="https://glow.williams.edu/courses/3619655">glow</a>
</center>
<hr>üö® please pull a fresh copy of the codebase before starting this homework!
üó£Ô∏è you are highly encouraged to collaborate on homework provided you follow the spirit of the <a href="http://courses.cms.caltech.edu/cs171/materials/pdfs/50ft_policy.pdf">50 ft rule</a>
üë• additionally, for this lab you may optionally choose to work with a partner
- only one of you is required to submit on glow (please add a glow comment saying who your partner is)
<hr>
<b>goals.</b>

- start understanding cameras
- get experience diving into an unfamiliar program
- play with a (very) simple architecture for a game

<hr>
<b>reading. coordinate systems</b>

a coordinate system is an x-axis $\mathbf{\hat x}$, a y-axis $\mathbf{\hat y}$, a z-axis $\mathbf{\hat z}$, and an origin $\mathbf{\hat o}$
the axes are vectors and the origin is a point
in homogeneous coordinates, it is convenient to pack a coordinate system into a 4x4 matrix like this

$\mathbf{C} = \begin{bmatrix}\mathbf{\hat x} & \mathbf{\hat y} & \mathbf{\hat z} & \mathbf{\hat o} \\ 0 & 0 & 0 & 1 \end{bmatrix}$

note that here it is implied that the quantities $\mathbf{\hat x}, \mathbf{\hat y}, \mathbf{\hat z}, \mathbf{\hat o}$ are written <i>in world coordinates</i>
the world coordinate system is there the identity matrix, which is nice :)


there are a few coordinate systems that are so special we give them names

<b>model coordinates</b> (aka modeling coordinates, aka object coordinates)
- this is the coordinate system of a single mesh
-- when you are modeling in Blender, you're working in model coordinates
-- when you were scripting up the cylinder by hand, you were working in model coordinates

<b>camera coordinates</b>
- this is the coordinate system of a virtual camera
-- by convention, the camera's x-axis (red) points its right, and y-axis (green) points up
--- assuming a right-handed coordinate system, this means the camera's z-axis (blue) points out its back

<b>world coordinates</b>
- this is the coordinate system of the world (scene)
-- when you place an object in the scene, you're working in world coordinates

<hr color="gray">

there are also a few matrices that are so special we give them names

<b>model matrix</b> $\mathbf{M}$
- it takes us to world coordinates <i>from</i> model coordinates, i.e. $\mathbf{p}_\text{world} = \mathbf{M}\mathbf{p}_\text{model}$

<b>camera matrix</b> $\mathbf{C}$
- it is the camera's axes and origin
  $\mathbf{C} = \begin{bmatrix}\mathbf{\hat x} & \mathbf{\hat y} & \mathbf{\hat z} & \mathbf{\hat o} \\ 0 & 0 & 0 & 1 \end{bmatrix}$
- as such, it takes us from camera coordinates to world coordinates, i.e., $\mathbf{p}_\text{world} = \mathbf{C}\mathbf{p}_\text{camera}$

<b>view matrix</b> $\mathbf{V} = \mathbf{C}^{-1}$
- it's just the inverse of the camera matrix
+ $\mathbf{C} = \begin{bmatrix}\mathbf{\hat x} & \mathbf{\hat y} & \mathbf{\hat z} & \mathbf{\hat o} \\ 0 & 0 & 0 & 1 \end{bmatrix}$


sidenote: more explicit notation with left and right subscripts
- model matrix $\mathbf{p}_\text{world} = {}_\text{world} \mathbf{A}_\text{model} \ \mathbf{p}_\text{model}$
- camera matrix $\mathbf{p}_\text{world} = {}_\text{world} \mathbf{A}_\text{camera} \ \mathbf{p}_\text{camera}$

<hr>
<b>reading. $\mathbf{V}$</b>

<hr>
<b>a. mini world</b>












</div></body></html>

<!--
<hr>
<b>‚òï. (extra credit) a wild fprintf and fscanf appeared; they look angry</b>

- save the teapot mesh to a file <b>teapot.obj</b> following the <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">obj</a> format
-- you will need to write, e.g., <code>void save_obj(IndexedTriangleMesh3D mesh, char *filename);</code> yourself
- load the mesh into <a href="https://www.meshlabjs.net/">meshlabjs</a> and run something fun (e.g., Quadric Simplification)
- download the resulting mesh as an obj
- load the resulting mesh into a cow app and draw it
-- (feel free to mess with the result from meshlabjs in a text editor a bit before loading to make your life easier)
-- you will need to write, e.g., <code>IndexedTriangleMesh3D load_obj(char *filename);</code> yourself
--- do NOT implement the entire obj spec; just implement the bare minimum that you need!
-->
